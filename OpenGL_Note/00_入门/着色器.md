# 着色器
着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。

## GLSL
着色器是使用一种叫GLSL的类C语言写成的，它包含一些针对向量和矩阵操作的有用特性。

着色器的开头总是要声明版本，接着是输入和输出变量、uniform和`main`函数。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。

一个典型的着色器有下面的结构：
```
#version version_number
in type in_variable_name;
in type in_variable_name;

out type out_variable_name;

uniform type uniform_name;

int main()
{
  // 处理输入并进行一些图形操作
  ...
  // 输出处理过的结果到输出变量
  out_variable_name = weird_stuff_we_processed;
}
```
当我们特别谈论到顶点着色器的时候，每个输入变量也叫==顶点属性==(Vertex Attribute)。我们能声明的顶点属性是有上限的，它一般由硬件来决定。OpenGL确保至少有16个包含4分量的顶点属性可用，但是有些硬件或许允许更多的顶点属性。

## 数据类型
和其他编程语言一样，GLSL有数据类型可以来指定变量的种类。GLSL中包含C等其它语言大部分的默认基础数据类型：`int`、`float`、`double`、`uint`和`bool`。GLSL也有两种容器类型，它们会在这个教程中使用很多，分别是向量(`Vector`)和矩阵(`Matrix`)，其中矩阵我们会在之后的教程里再讨论。

### 向量
GLSL中的向量是一个可以包含有1、2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。它们可以是下面的形式（`n`代表分量的数量）：

| 类型 | 含义 |
| :- | :- |
|`vecn` | 包含n个`float`分量的默认向量 |
|`bvecn` | 包含n个`bool`分量的向量 |
|`ivecn` | 包含n个`int`分量的向量 |
|`uvecn` |包含n个`unsigned int`分量的向量 |
|`dvecn` | 包含n个`double`分量的向量 |


一个向量的分量可以通过`vec.x`这种方式获取，这里`x`是指这个向量的第一个分量。你可以分别使用`.x`、`.y`、`.z`和`.w`来获取它们的第1、2、3、4个分量。GLSL也允许你对颜色使用`rgba`，或是对纹理坐标使用`stpq`访问相同的分量。
向量这一数据类型也允许一些有趣而灵活的分量选择方式，叫做==重组==(Swizzling)。

## 输入与输出
GLSL定义了`in`和`out`关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但在顶点和片段着色器中会有点不同。

顶点着色器应该接收的是一种特殊形式的输入，否则就会效率低下。顶点着色器的输入特殊在，它从顶点数据中直接接收输入。为了定义顶点数据该如何管理，我们使用`location`这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。我们已经在前面的教程看过这个了，`layout (location = 0)`。顶点着色器需要为它的输入提供一个额外的`layout`标识，这样我们才能把它链接到顶点数据。

另一个例外是片段着色器，它需要一个`vec4`颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）。

如果我们在[[你好，三角形#顶点着色器|顶点着色器]]中声明了一个`vertexColor`变量作为`vec4`输出，并在[[你好，三角形#片段着色器|片段着色器]]中声明了一个类似的`vertexColor`。由于它们名字相同且类型相同，片段着色器中的`vertexColor`就和顶点着色器中的`vertexColor`链接了。

## Uniform
==Uniform==是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是==全局的==(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是**独一无二**的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。

使用uniform步骤：在着色器中声明uniform变量 --> 用`glGetUniformLocation`查询uniform变量的位置值 --> 使用`glUniformxx`函数设置uniform值
在更新一个uniform值之前**必须先使用程序**(调用`glUseProgram`)。

## 更多属性！
可以将颜色数据也加进顶点数据中，此时需要用`layout`标识符来把aColor属性的位置值改变。
因为我们添加了另一个顶点属性，并且更新了VBO的内存，我们就必须重新配置顶点属性指针。

这个图片可能不是你所期望的那种，因为我们只提供了3个颜色，而不是我们现在看到的大调色板。这是在片段着色器中进行的所谓==片段插值==(Fragment Interpolation)的结果。当渲染一个三角形时，光栅化(Rasterization)阶段通常会**造成比原指定顶点更多的片段**。光栅会根据每个片段在三角形形状上所处相对位置决定这些片段的位置。
基于这些位置，它会==插值==(Interpolate)**所有片段着色器的输入变量**。比如说，我们有一个线段，上面的端点是绿色的，下面的端点是蓝色的。如果一个片段着色器在线段的70%的位置运行，它的颜色输入属性就会是一个绿色和蓝色的线性结合；更精确地说就是30%蓝 + 70%绿。

## 我们自己的着色器类

